<?xml version="1.0" encoding="UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  xsi:noNamespaceSchemaLocation="messagecollection.xsd">

	<Plugin>
	    <ShortDescription>fb-contrib plugin</ShortDescription>
	    <Details>
			<![CDATA[
			<p>
			This plugin contains FindBugs detectors from the fb-contrib project
			</p>
			]]>
	    </Details>
	</Plugin>

	<!-- Detectors -->

    <Detector class="com.mebigfatguy.fbcontrib.collect.CollectStatistics">
    	<Details>
			<![CDATA[
			<p>Collects statistics for other detectors</p>
			]]>
    	</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InefficientStringBuffering">
	    <Details>
			<![CDATA[
			<p> Looks for appending strings inside of calls to StringBuffer or StringBuilder append.</p>
			<p> <pre>
				StringBuffer sb = new StringBuffer();
				sb.append(a + b);
				return sb.toString();
			</pre></p>
			<p>It is a fast detector</p>
			]]>
	    </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SyncCollectionIterators">
	    <Details>
			<![CDATA[
			<p> Looks for use of iterators on synchronized collections built from the Collections class</p>
			<p> As the collection in question was built thru Collections.synchronizedXXX, an assumption
			is made that this collection must be multithreaded safe. However, iterator access is used,
			which is explicitly unsafe. When iterators are to be used, synchronization should be done manually.</p>
			<p>It is a slow detector</p>
			]]>
	    </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CyclomaticComplexity">
	    <Details>
			<![CDATA[
			<p> Calculates the McCabe Cyclomatic Complexity measure and reports methods that have an
			excessive value. This report value can be set with system property 'fb-contrib.cc.limit'.</p>
			<p>It is a slow detector</p>
			]]>
	    </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OverlyConcreteParameter">
	    <Details>
			<![CDATA[
			<p> Looks for parameters that are defined by classes, but only use methods defined by an
			implemented interface or super class. Relying on concrete classes in public signatures causes cohesion,
			and makes low impact changes more difficult.</p>
			<p>It is a slow detector</p>
			]]>
	    </Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ListIndexedIterating">
		<Details>
			<![CDATA[
			<p> Looks for for loops that iterate over a java.util.List using an integer index, and get,
			rather than using an Iterator. An iterator may perform better depending List implementation,
			but more importantly will allow the code to be converted to other collections type.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedCollectionContents">
		<Details>
			<![CDATA[
			<p> Looks for collections or arrays that hold objects that are unrelated thru class or
			interface inheritance other than java.lang.Object. Doing so, makes for brittle code,
			relying either on positional correspondence for type, or a reliance on instanceof to
			determine type. A better design usually can be had by creating a seperate class,
			which defines the different types required, and add an instance of that class to the
			collection, or array.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DeclaredRuntimeException">
		<Details>
			<![CDATA[
			<p> Looks for methods that declare Runtime exceptions in their throws clause. While doing
			so is not illegal, it may represent a misunderstanding as to the exception in question.
			If a RuntimeException is declared, it implies that this exception type is expected to happen,
			which if true, should be handled in code, and not propogated. </p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ClassEnvy">
		<Details>
			<![CDATA[
			<p><b>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</b></p>
			<p> Looks for methods that use a high percentage of methods from another class over it's own
			methods. When this is the case, it is often better to implement this method in that other class,
			by refactoring the class to accept parameters it needs from the source class.
			The reporting percentage can be set with system property 'fb-contrib.ce.percent'.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LiteralStringComparison">
		<Details>
			<![CDATA[
			<p> Looks for methods that compare strings against literal strings, where the literal string
			is passed as the parameter. If the .equals or .compareTo is called on the literal itself, passing
			the variable as the parameter, you avoid the possibility of a NullPointerException.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PartiallyConstructedObjectAccess">
		<Details>
			<![CDATA[
			<p> Looks for constructors of non final classes that make method calls to non final methods.
			As these methods could be overridden, the overridden method will be accessing an object that
			is only partially constructed, perhaps causing problems.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DubiousListCollection">
		<Details>
			<![CDATA[
			<p> Looks for constructors of non final classes that make method calls to non final methods.
			As these methods could be overridden, the overridden method will be accessing an object that
			is only partially constructed, perhaps causing problems.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ParallelLists">
		<Details>
			<![CDATA[
			<p> Looks for classes that maintain two or more lists or arrays associated one-for-one through the same index
			to hold two or more pieces of related information. It would be better to create a new class that holds
			all of these pieces of information, and place instances of this class in one list.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FinalParameters">
		<Details>
			<![CDATA[
			<p>Looks for methods that correctly do not write to a parameter. To help document this, and to perhaps
			help the jvm optimize the invocation of this method, you should consider defining these parameters
			as final.</p>
			<p>It is a slow detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbstractClassEmptyMethods">
		<Details>
			<![CDATA[
			<p> Looks for abstract classes that define empty methods or methods that simply throw an
			exception. Since this is an abstract class, it may be cleaner to simple define this method
			as abstract, so that correct subclass behaviour is enforced.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ManualArrayCopy">
		<Details>
			<![CDATA[
			<p> Looks for methods that copy data from one array to another using a loop. It is
			better performing to use System.arraycopy to do such copying as this is a native method.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FloatingPointLoops">
		<Details>
			<![CDATA[
			<p> Looks for methods that use floating point indexes for loops. Since floating point
			math is inprecise, rounding errors will occur each time through the loop causing
			hard to find problems. It is usually better to use integer indexing, and calculating
			the correct floating point value from the index.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonCollectionMethodUse">
		<Details>
			<![CDATA[
			<p> Looks for method calls to collection classes where the method is not defined by the Collections
			interface, and an equivalent method exists in the interface. Examples include:<br>
			<table border="1">
				<tr><th>Old Method</th><th>New Method</th></tr>
				<tr><td>Hashtable.contains</td><td>Map.containsValue</td></tr>
				<tr><td>Hashtable.elements</td><td>Map.elements</td></tr>
				<tr><td>Hashtable.keys</td><td>Map.keySet</td></tr>
				<tr><td>Vector.addElement</td><td>List.add</td></tr>
				<tr><td>Vector.elementAt</td><td>List.get</td></tr>
				<tr><td>Vector.insertElementAt</td><td>List.add</td></tr>
				<tr><td>Vector.removeAllElements</td><td>List.clear</td></tr>
				<tr><td>Vector.removeElement</td><td>List.remove</td></tr>
				<tr><td>Vector.removeElementAt</td><td>List.remove</td></tr>
				<tr><td>Vector.setElementAt</td><td>List.set</td></tr>
			</table>
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingAutoboxedOverloading">
		<Details>
			<![CDATA[
			<p> Looks for methods that have the same signature, except where one uses a
			Character parameter, and the other uses an int, long, float, double parameter.
			Since autoboxing is available in 1.5 one might assume that
			<pre>
			test('a')
			</pre>
			would map to
			<pre>
			public void test(Character c)
			</pre>
			but instead maps to one that takes an int long, float or double.
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbnormalFinallyBlockReturn">
		<Details>
			<![CDATA[
			<p> Looks for methods that have finally blocks that return values
			or throw exceptions. This code will swallow normal program flow and
			hide real program logic.
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StaticMethodInstanceInvocation">
		<Details>
			<![CDATA[
			<p> Looks for methods that make static method calls using an instance reference.
			For documentation purposes, it is better to call the method using the class name.
			This may represent a change in definition that should be noticed.
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SpuriousThreadStates">
		<Details>
			<![CDATA[
			<p> Looks for methods that call wait, notify or notifyAll on an instance of a
			java.lang.Thread. Since the internal workings of the threads is to synchronize on the
			thread itself, introducing client calls will confuse the thread state of the object
			in question, and will cause spurious thread state changes, either waking threads up
			when not intended, or removing the thread from the runnable state.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessAutoboxing">
		<Details>
			<![CDATA[
			<p> Looks for methods that pass a primitive wrapper class object, to the
			same classes Constructor. Patterns found are:
			<ul>
				<li>new Boolean(Boolean)</li>
				<li>new Byte(Byte)</li>
				<li>new Character(Character)</li>
				<li>new Short(Short)</li>
				<li>new Integer(Integer)</li>
				<li>new Long(Long)</li>
				<li>new Float(Float)</li>
				<li>new Double(Double)</li>
			</ul>
			</p>
			<p>It also looks for calls to BoxedClass.valueOf(x) where X is already a Boxed class</p>
			<p>It also looks for calls to BoxedClass.valueOf(myString).boxedValue(), When instead it is
			simpler to use BoxedClass.parseBoxed(myString)</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryStoreBeforeReturn">
		<Details>
			<![CDATA[
			<p>Looks for methods that store the return result in a local variable, and
			then immediately returns that local variable.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CopiedOverriddenMethod">
		<Details>
			<![CDATA[
			<p>Looks for methods that are direct copies of the implementation in the super class</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ArrayBasedCollections">
		<Details>
			<![CDATA[
			<p>Looks for methods that use arrays for items in the keyset of a map, or as
			an element of a set, or in a list when using the contains method. Since arrays
			do not, and cannot define an equals method, reference equality is used for these
			collections, which is probably not desired. If it is, consider using the IdentityHashMap
			class when using Maps in this case, to better document your intentions.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OrphanedDOMNode">
		<Details>
			<![CDATA[
			<p>Looks for methods that create DOM Nodes but do not add them to any DOM Document.</p>
			<p>It is a fast Detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbstractOverriddenMethod">
		<Details>
			<![CDATA[
			<p>Looks for methods that are declared as abstract that override concrete methods in a
			super class. Doing this casts away the implementation of the super class, and breaks
			the contract as set forth by the parent class.</p>
			<p>It is a fast Detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CustomBuiltXML">
		<Details>
			<![CDATA[
			<p>Looks for methods that build xml based strings by concatenation strings
			and custom values together. Doing so makes brittle code, that is difficult to
			modify, validate and understand. It is cleaner to create external xml files that are
			transformed at runtime, using parameters set through Transformer.setParameter.
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BloatedSynchronizedBlock">
		<Details>
			<![CDATA[
			<p>Looks for methods that are implemented using synchronized blocks, but are overly
			synchronized because the beginning of the block only accesses local variables,
			and not member variables, or this.</p>
			<p>It is a slow detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConstantListIndex">
		<Details>
			<![CDATA[
			<p>Looks for methods that access arrays or classes that implement java.util.List
			using a constant integer for the index. This is often a typo intented to be a loop
			variable, but if specific indices mean certain things, perhaps a first class object
			would be a better choice for a container.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SloppyClassReflection">
		<Details>
			<![CDATA[
			<p>Looks for methods that use Class.forName("XXX") to load a class object
			for a class that is already referenced by this class. It is simpler to just use
			XXX.class, and doing so protects the integrity of this code from such transformations
			as obfuscation. Use of Class.forName should only be used when the class in question
			isn't already statically bound to this context.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ArrayWrappedCallByReference">
		<Details>
			<![CDATA[
			<p>Looks for methods that use an array of length one to pass a variable to achieve call
			by pointer ala C++. It is better to define a proper return class type that holds all
			the relevant information retrieved from the called method.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SluggishGui">
		<Details>
			<![CDATA[
			<p>Looks for methods that implement awt or swing listeners and perform time
			consuming operations. Doing these operations in the gui thread will cause the
			interface to appear sluggish and non-responsive to the user. It is better to
			use a separate thread to do the time consuming work so that the user
			has a better experience.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessInstanceRetrieval">
		<Details>
			<![CDATA[
			<p>Looks for methods that call a method to retrieve a reference to an object,
			to use to load a constant. It is simpler and more performant to access the
			static variable directly from the class itself.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DateComparison">
	   <Details>
			<![CDATA[
			<p> Looks for inefficient comparison of Date objects using two comparisons when one would do.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousWaitOnConcurrentObject">
		<Details>
			<![CDATA[
			<p>Looks for calls to the wait method on mutexes defined in the java.util.concurrent
			package where it is likely that await was intended.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.JDBCVendorReliance">
		<Details>
			<![CDATA[
			<p>Looks for uses of jdbc vendor specific classes and methods making the database
			access code non portable.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleMemoryBloat">
		<Details>
			<![CDATA[
			<p>looks for classes that maintain collections or StringBuffer/StringBuilders in
			static member variables, and that do not appear to provide a way to clear or remove
			items from these members. Such class fields are likely causes of memory bloat.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LocalSynchronizedCollection">
		<Details>
			<![CDATA[
			<p>looks for allocations of synchronized collections that are stored in local
			variables, and never stored in fields or returned from methods. As local variables
			are by definition thread safe, using synchronized collections in this context
			makes no sense.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FieldCouldBeLocal">
		<Details>
			<![CDATA[
			<p>looks for classes that define fields that are used in a locals only fashion,
			specifically private fields that are accessed first in each method with a
			store vs. a load.</p>
			<p>It is a slow detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonOwnedSynchronization">
		<Details>
			<![CDATA[
			<p>looks for methods that synchronize on variables that are not owned by the
			current class. Doing this causes confusion when two classes use the same variable
			for their own synchronization purposes. For cleanest separation of interests, only
			synchronize on private fields of the class. Note that 'this' is not owned by
			the current class and synchronization on 'this' should be avoided as well.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonRecycleableTaglibs">
		<Details>
			<![CDATA[
			<p>looks for tag libraries that are not recycleable because backing members
			of taglib attributes are set in areas besides the setter method for the attribute.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.Section508Compliance">
		<Details>
			<![CDATA[
				<p>looks for violation of Section 508, Accessibility for People with disabilities Act.
				</p>
				<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseEnumCollections">
		<Details>
			<![CDATA[
			<p>looks for use of sets and maps using enums. It is more efficient to use EnumSet or EnumMap</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SQLInLoop">
		<Details>
			<![CDATA[
			<p>looks for the execution of sql queries inside a loop. This pattern tends to be inefficient,
			and often can be improved upon, by collecting all the keys needed for the query and issuing just
			one query using an in clause with all the keys for all the queries previously needed in the loop.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessMemberCollectionSynchronization">
		<Details>
			<![CDATA[
			<p>looks for classes that define private synchronized collections as static or instance
			members, that are only altered in a static initializer or constructor. Since the multithreaded
			use of this collection is read-only, the use of synchronization is unnecessary.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InheritanceTypeChecking">
		<Details>
			<![CDATA[
			<p>looks for if/else blocks where a series of them use instanceof on the same
			variable to determine what to do. If these classes are related by inheritance,
			this often is better handled through calling a single overridden method.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StaticArrayCreatedInMethod">
		<Details>
			<![CDATA[
			<p>looks for creation of arrays in methods using constant values. These arrays
			will need to be recreated each time the method is called. These arrays should probably
			be defined as static fields, instead</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossiblyRedundantMethodCalls">
		<Details>
			<![CDATA[
			<p>looks for calls of the same method on the same object when that object hasn't changed.
			This often is redundant, and the second call can be removed, or combined.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseToArray">
		<Details>
			<![CDATA[
			<p>looks for code that builds an array of values from a collection, by manually looping
			over the elements of the collection, and adding them to the array. It is simpler and
			cleaner to use mycollection.toArray(new type[mycollection.size()].</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LostExceptionStackTrace">
		<Details>
			<![CDATA[
			<p>looks for methods that catch exceptions, and then throw a different exception,
			without embedding the original exception in the thrown one. Doing so, hides the real
			source of the exception, making debugging and fixing these problems difficult.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseCharacterParameterizedMethod">
		<Details>
			<![CDATA[
			<p>looks for methods that pass single character string constants as parameters to
			methods that alternatively have an overridden method that accepts a character instead.
			It is easier for the method to handle a single character than a String.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.TailRecursion">
		<Details>
			<![CDATA[
			<p>looks for methods that make a recursive call to itself as the last statement in the
			method. This tail recursion could be converted into a simple loop which would improve
			the performance and stack requirements.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedReturnValues">
		<Details>
			<![CDATA[
			<p>looks for methods that are defined to return Object, and return different types of
			objects based on different code paths. If this method is not based on a interface or
			superclass, it is suggested to change the return type to a type that would accomodate
			all kinds of return types.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleIncompleteSerialization">
		<Details>
			<![CDATA[
			<p>looks for classes that don't handle serialization of parent class member fields
			when the class in question is serializable but is derived from a non serializable
			classes.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousComparatorReturnValues">
		<Details>
			<![CDATA[
			<p>looks for class that implement Comparator or Comparable, and whose compare or compareTo
 			methods return constant values only, but that don't represent the three possible choice
			(a negative number, 0, and a positive number).</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SillynessPotPourri">
		<Details>
			<![CDATA[
			<p>looks for a potpourri of small problems that do not fit into a common pattern.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BloatedAssignmentScope">
		<Details>
			<![CDATA[
			<p><b>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</b>
			Looks for assignments to variables in a scope larger than it's use. As long as the evaluation of the assignment
			does not have side effects, the assignment can be moved into the inner scope where it is used.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SpoiledChildInterfaceImplementor">
		<Details>
			<![CDATA[
			<p>looks for classes that implement interfaces by relying on methods being
			implemented in superclasses, even tho the superclass knows nothing about
			the interface being implemented by the child.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DeletingWhileIterating">
		<Details>
			<![CDATA[
			<p>looks for deletion of items from a collection using the remove method
			of the collection at the same time that the collection is being iterated on. If
			this occurs the iterator will become invalid and throw a ConcurrentModificationException.
			Instead, the remove should be called on the iterator itself.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseSplit">
		<Details>
			<![CDATA[
			<p>looks for code that builds an array by using a StringTokenizer to break up
			a string and place individual elements into an array. It is simpler to use
			String.split instead.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousJDKVersionUse">
		<Details>
			<![CDATA[
			<p>looks for calls to classes and methods that do not exist in the JDK for which this class is
			compiled. This can happen if you specify the -source and -target options of the javac compiler, and
			specify a target that is less than the jdk version of the javac compiler.</p>
			<p>It is a slow detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseAddAll">
		<Details>
			<![CDATA[
			<p>looks for loops that transfers the contents of one collection to another. These collection sources might
			be local variables or member fields, including sets, maps key/values, lists, or arrays. It is simpler to
			just use the addAll method of the collection class. In the case where the source is an array, you can use
			Arrays.asList(array), and use that as the source to addAll.</p>
			<p>It is a fast detector.</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.MethodReturnsConstant">
		<Details>
			<![CDATA[
			<p>looks for private methods that only return one constant value. Since there is no
			chance for derived classes overriding this behavior, the return of a constant value
			seems dubious.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessCustomSerialization">
		<Details>
			<![CDATA[
			<p>looks for classes that implement the Serializable interface and implement the
			standard readObject and writeObject methods by simply deferring to the Stream
			parameter's defaultReadObject or defaultWriteObject and nothing else. As this is the
			built in behavior, these methods are not needed.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.MisleadingOverloadModel">
		<Details>
			<![CDATA[
			<p>looks for classes that define both static and instance methods with the same name.
			As each type represents a different use model, it doesn't make sense that this name
			would be overloaded, and will confuse users of the class.</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ExceptionSoftening">
		<Details>
			<![CDATA[
			<p>looks for methods that catch checked exceptions, and throw unchecked
			exceptions in their place. There are several levels of concern. Least
			concerning are methods constrained by interface or super class contracts
			not to throw checked exceptions but appear owned by the same author. Next
			are methods constrained by interface or super class contracts and throw other
			types of checked exceptions. Most egregious are method not constrained by any interface
			or superclass contract.</p>
			<p>It is a moderately fast detector</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingFunctionSemantics">
		<Details>
			<![CDATA[
			<p>looks for methods that return a parameter after modifying that parameter.
			Doing this will confuse the user of this method, as it will be assumed that the
			passed in argument is different than the output, or at least won't be changed.
			If the purpose of this method is just to modify the parameter, this method should
			probably be changed to have a void return type. If you must return a variable, perhaps
			a clone of the parameter should be returned.
			</p>
			<p>It is a fast detector</p>
			]]>
		</Details>
	</Detector>

	<!-- BugPattern -->

	<BugPattern type="ISB_INEFFICIENT_STRING_BUFFERING">
	    <ShortDescription>method passes simple concatenating string in StringBuffer or StringBuilder append</ShortDescription>
	    <LongDescription>method {1} passes simple concatenating string in StringBuffer or StringBuilder append</LongDescription>
	    <Details>
			<![CDATA[
			<p> This method uses StringBuffer or StringBuilder append to concatenate strings. However, it passes the result
			of doing a simple String concatenation to one of these append calls, thus removing any performance gains
			of using the StringBuffer or StringBuilder class.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="ISB_EMPTY_STRING_APPENDING">
	    <ShortDescription>method concatenates an empty string to effect type conversion</ShortDescription>
	    <LongDescription>method {1} concatenates an empty string to effect type conversion</LongDescription>
	    <Details>
			<![CDATA[
			<p> This method concatenates an empty string with a literal value, in order to convert
			the literal value into a string. It is more efficient to use String.valueOf() to do the same
			thing as you do not incur the cost of creating a StringBuffer/Builder and calling methods on it
			to accomplish this.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="SCI_SYNCHRONIZED_COLLECTION_ITERATORS">
	    <ShortDescription>method creates iterators on synchronized collections</ShortDescription>
	    <LongDescription>method {1} creates iterators on synchronized collections</LongDescription>
	    <Details>
			<![CDATA[
			<p> This method uses a synchronized collection, built from Collections.synchronizedXXXX, but accesses it
			through an iterator. Since an iterator is by definition, multithreaded unsafe, this is a conflict in
			concept. When using iterators, you should do the synchronization manually.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="CC_CYCLOMATIC_COMPLEXITY">
	    <ShortDescription>method is excessively complex</ShortDescription>
	    <LongDescription>method {1} is excessively complex</LongDescription>
	    <Details>
			<![CDATA[
			<p> This method has a high cyclomatic complexity figure, which calculates the number of branch
			points. It is likely difficult to test, and is brittle to change. Consider refactoring this
			method into several to reduce the risk.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="OCP_OVERLY_CONCRETE_PARAMETER">
	    <ShortDescription>method needlessly defines parameter with concrete classes</ShortDescription>
	    <LongDescription>method {1} needlessly defines parameter with concrete classes</LongDescription>
	    <Details>
			<![CDATA[
			<p> This method uses concrete classes for parameters when only methods defined in an implemented
			interface or super class are used. Consider increasing the abstraction of the interface to
			make low impact changes easier to accomplish in the future.</p>
			]]>
	    </Details>
	</BugPattern>

	<BugPattern type="LII_LIST_INDEXED_ITERATING">
		<ShortDescription>method uses integer based for loops to iterate over a List</ShortDescription>
		<LongDescription>method {1} uses integer based for loops to iterate over a List</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses an integer based for loop to iterator over a java.util.List, by calling
			List.get(i) each time thru the loop. The integer is not used for other reasons. It is better
			to use an Iterator instead, as depending on List implementation, iterators can perform better,
			and they also allow for exchanging of other collection types without issue.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UCC_UNRELATED_COLLECTION_CONTENTS">
		<ShortDescription>method adds unrelated types to collection or array</ShortDescription>
		<LongDescription>method {1} adds unrelated types to collection or array</LongDescription>
		<Details>
			<![CDATA[
			<p>This method adds unrelated objects to a collection or array, requiring careful and brittle
			data access to that collection. Create a separate class with properties needed, and add
			an instance of this class to the collection or array, if possible.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DRE_DECLARED_RUNTIME_EXCEPTION">
		<ShortDescription>method declares RuntimeException in throws clause</ShortDescription>
		<LongDescription>method {1} declares RuntimeException in throws clause</LongDescription>
		<Details>
			<![CDATA[
			<p>This method declares a RuntimeException derived class in it's throws clause.
			This may indicate a misunderstanding as to how unchecked exceptions are handled.
			If is felt that a RuntimeException is so prevalent that it should be declared, it
			is probably a better idea to prevent the occurance in code.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CE_CLASS_ENVY">
		<ShortDescription>method excessively uses methods of another class</ShortDescription>
		<LongDescription>method {1} excessively uses methods of another class</LongDescription>
		<Details>
			<![CDATA[
			<p><b>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</b></p>
			<p>This method makes extensive use of methods from another class over methods of it's own
			class. Typically this means that the functionality that is accomplished by this method
			most likely belongs with the class that is being used so liberally. Consider refactoring this
			method to be contained in that class, and to accept all the parameters needed in the method signature.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LSC_LITERAL_STRING_COMPARISON">
		<ShortDescription>method makes literal string comparisons passing the literal as an argument</ShortDescription>
		<LongDescription>method {1} makes literal string comparisons passing the literal as an argument</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the equals or compareTo methods on a String variable passing in a String literal.
			A NullPointerException may occur if the string variable is null. If instead the method was called on
			the string literal, and the variable was passed as an argument, this exception could never happen.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PCOA_PARTIALLY_CONSTRUCTED_OBJECT_ACCESS">
		<ShortDescription>constructor makes call to non-final method</ShortDescription>
		<LongDescription>constructor {1} makes call to non-final method</LongDescription>
		<Details>
			<![CDATA[
			<p>This constructor makes a call to a non-final method. Since this method can be overriden, a subclasses
			implementation will be executing against an object that has not been initialized at the subclass level.
			You should mark all methods called from the constructor as final to avoid this problem.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DLC_DUBIOUS_LIST_COLLECTION">
		<ShortDescription>class defines List based fields but uses them like Sets</ShortDescription>
		<LongDescription>class {0} defines List based fields but uses them like Sets</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines a field based on java.util.List, but uses it to some extent like a Set. Since
			lookup type operations are performed using a linear search for Lists, the performance for large
			Lists will be poor. Consider changing this fields implementation to a set based one. If order of
			iteration is important to maintain insert order, perhaps consider a LinkedHashSet.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PL_PARALLEL_LISTS">
		<ShortDescription>class defines two or more one for one associated lists or arrays</ShortDescription>
		<LongDescription>class {0} defines two or more one for one associated lists or arrays</LongDescription>
		<Details>
			<![CDATA[
			<p>This class appears to maintain two or more lists or arrays who's contains is related one-for-one
			through the index of the list or array. Consider creating a separate class to hold all the related
			pieces of information, and adding instances of this class to just one list or array.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FP_FINAL_PARAMETERS">
		<ShortDescription>method does not define a parameter as final, but could</ShortDescription>
		<LongDescription>method {1} does not define a parameter as final, but could</LongDescription>
		<Details>
			<![CDATA[
			<p>This method correctly does not write to a parameter. To help document this, and to perhaps
			help the jvm optimize the invocation of this method, you should consider defining these parameters
			as final.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ACEM_ABSTRACT_CLASS_EMPTY_METHODS">
		<ShortDescription>empty method could be declared abstract</ShortDescription>
		<LongDescription>empty method {1} could be declared abstract</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is empty or merely throws an exception. Since the class it is defined in is
			abstract, it may be more correct to define this method as abstract instead, so that proper
			subclass behavior is enforced.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MAC_MANUAL_ARRAY_COPY">
		<ShortDescription>method copies arrays manually</ShortDescription>
		<LongDescription>method {1} copies arrays manually</LongDescription>
		<Details>
			<![CDATA[
			<p>This method copies data from one array to another manually using a loop.
			It is much better performing to use System.arraycopy as this method is native.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FPL_FLOATING_POINT_LOOPS">
		<ShortDescription>method uses floating point indexed loops</ShortDescription>
		<LongDescription>method {1} uses floating point indexed loops</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses floating point variables to index a loop. Since floating point
			math is inprecise, rounding errors will accumulate over time each time the loop is
			executed. It is usually better to use integer indexing, and calculate the new value
			of the floating point number at the top of the loop body.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NCMU_NON_COLLECTION_METHOD_USE">
		<ShortDescription>method uses old non collections interface methods</ShortDescription>
		<LongDescription>method {1} uses old non collections interface methods</LongDescription>
		<Details>
			<![CDATA[
			<p>This method makes calls to collection classes where the method is not defined by the Collections
			interface, and an equivalent method exists in the interface. By using the new methods,
			you can define this object by the Collections interface and allow better decoupling.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CAO_CONFUSING_AUTOBOXED_OVERLOADING">
		<ShortDescription>class defines methods which confuse Character with int parameters</ShortDescription>
		<LongDescription>class {0} defines methods which confuse Character with int parameters</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines two methods that differ only by a parameter being defined
			as Character vs. int, long, float or double. As autoboxing is present, it may be
			assumed that a parameter of 'a' would map to the Character version, but does not.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AFBR_ABNORMAL_FINALLY_BLOCK_RETURN">
		<ShortDescription>class has abnormal exit from finally block</ShortDescription>
		<LongDescription>class {0} has abnormal exit from finally block</LongDescription>
		<Details>
			<![CDATA[
			<p>This class returns or throws exceptions from a finally block. This will
			mask real program logic in the try block, and short-circuit normal method termination.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SMII_STATIC_METHOD_INSTANCE_INVOCATION">
		<ShortDescription>method calls static method on instance reference</ShortDescription>
		<LongDescription>method {1} calls static method on instance reference</LongDescription>
		<Details>
			<![CDATA[
			<p>This method makes a static method call on an instance reference. For
			reading comprehension of the code is better to call the method on the class,
			rather than an instance. Perhaps this method's static nature has changed since
			this code was written, and should be revisited.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="STS_SPURIOUS_THREAD_STATES">
		<ShortDescription>method calls wait, notify or notifyAll on a Thread instance</ShortDescription>
		<LongDescription>method {1} calls wait, notify or notifyAll on a Thread instance</LongDescription>
		<Details>
			<![CDATA[
			<p>This method invokes the methods wait, notify or notifyAll on a Thread instance.
			Doing so will confuse the internal thread state behaviour causing spurious thread
			wakeups/sleeps because the internal mechanism also uses the thread instance for it's
			notifications.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_AUTOBOXING_CTOR">
		<ShortDescription>method passes primitive wrapper to same primitive wrapper constructor</ShortDescription>
		<LongDescription>method {1} passes primitive wrapper to same primitive wrapper constructor</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a wrapped primitive object to the same class's constructor.
			Since wrapper classes are immutable, you can just use the original object, rather
			than constructing a new one. This code works because of an abuse of autoboxing.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_STRING_CTOR">
		<ShortDescription>method passes parsed string to primitive wrapper constructor</ShortDescription>
		<LongDescription>method {1} passes parsed string to primitive wrapper constructor</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a primitive value retrieved from a BoxedPrimitive.parseBoxedPrimitive("1") call to
			the same class's constructor. It is simpler to just pass the string to the BoxedPrimitives constructor.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_AUTOBOXING_VALUEOF">
		<ShortDescription>method passes primitive wrapper to Wrapper class valueOf method</ShortDescription>
		<LongDescription>method {1} passes primitive wrapper to Wrapper class valueOf method</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a wrapped primitive object to the same class's .valueOf method.
			Since wrapper classes are immutable, you can just use the original object, rather
			than calling valueOf to create a new one. This code works because of an abuse of autoboxing.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_PARSE">
		<ShortDescription>method converts String to primitive using excessive boxing</ShortDescription>
		<LongDescription>method {1} converts String to primitive using excessive boxing</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a String to a wrapped primitive object's valueOf method, which in turn calls
			the boxedValue() method to convert to a primitive. When it is desired to convert from a String
			to a primitive value, it is simpler to use the BoxedPrimitive.parseBoxedPrimitive(myString)
			method. </p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_VALUEOF">
		<ShortDescription>method converts String to boxed primitive using excessive boxing</ShortDescription>
		<LongDescription>method {1} converts String to boxed primitive using excessive boxing</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a String to a wrapped primitive object's parse method, which in turn calls
			the valueOf() method to convert to a boxed primitive. When it is desired to convert from a String
			to a boxed primitive object, it is simpler to use the BoxedPrimitive.valueOf(myString)
			method. </p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOX_TO_UNBOX">
		<ShortDescription>method creates Boxed primitive from primitive only to get primitive value</ShortDescription>
		<LongDescription>method {1} creates Boxed primitive from primitive only to get primitive value</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a Boxed Primitive from a primitive only to call the primitiveValue() method to
			convert it back to a primitive. Just use the primitive value instead.</p>
			<pre>
				primitive i = new BoxedPrimitive(1).primitiveValue();
					or
				primitive i = BoxedPrimitive.valueOf(1).primitiveValue();

					should just use
				primitive i = 1;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOX_TO_CAST">
		<ShortDescription>method creates Boxed primitive from primitive only to cast to another primitive type</ShortDescription>
		<LongDescription>method {1} creates Boxed primitive from primitive only to cast to another primitive type</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a Boxed Primitive from a primitive only to call the primitiveValue() method to
			cast the value to another primitive typee. It is simpler to just use casting</p>
			<pre>
				primitive i = new BoxedPrimitive(1.0).primitiveValue();
					or
				primitive i = BoxedPrimitive.valueOf(1.0).primitiveValue();

					should just use
				primitive i = (primitive)1.0;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="USBR_UNNECESSARY_STORE_BEFORE_RETURN">
		<ShortDescription>method stores return result in local before immediately returning it</ShortDescription>
		<LongDescription>method {1} stores return result in local before immediately returning it</LongDescription>
		<Details>
			<![CDATA[
			<p>This method stores the return result in a local variable, and then immediately
			returns the local variable. It would be simpler just to return the value that is
			assigned to the local variable, directly.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="COM_COPIED_OVERRIDDEN_METHOD">
		<ShortDescription>method is implemented with an exact copy of it's superclass's method</ShortDescription>
		<LongDescription>method {1} is implemented with an exact copy of it's superclass's method</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is implemented using an exact copy of it's super class method's
			implementation, which usually means that this method can just be removed.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ABC_ARRAY_BASED_COLLECTIONS">
		<ShortDescription>method uses array as basis of collection</ShortDescription>
		<LongDescription>method {1} uses array as basis of collection</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes an array as the key to a Map, element in a Set, or item in a List when
			the contains method is used on the List. Since arrays do not, and cannot override the equals
			method, collection inclusion is based on the reference's address, which is probably not desired.
			In the case that this is a TreeMap or TreeSet, consider passing a Comparator to the map's
			constructor.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ODN_ORPHANED_DOM_NODE">
		<ShortDescription>method creates DOM node but doesn't attach it to a document</ShortDescription>
		<LongDescription>method {1} creates DOM node but doesn't attach it to a document</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a DOM node but does not attach it to a DOM document.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AOM_ABSTRACT_OVERRIDDEN_METHOD">
		<ShortDescription>abstract method overrides a concrete implementation</ShortDescription>
		<LongDescription>abstract method {1} overrides a concrete implementation</LongDescription>
		<Details>
			<![CDATA[
			<p>This abstract method is derived from a concrete method implementation. It is highly
			suspect that the super class method's implementation would be cast away.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CBX_CUSTOM_BUILT_XML">
		<ShortDescription>method builds xml strings through adhoc concatenation</ShortDescription>
		<LongDescription>method {1} builds xml strings through adhoc concatenation</LongDescription>
		<Details>
			<![CDATA[
			<p>This method generates an xml based string by concatenating together various
			xml fragments, and variable values. Doing so makes the code difficult to read, modify
			and validate. It is much more clean to built xml structures in external files that are
			read in and transformed into the final product, thru modification by Transformer.setParameter.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="BSB_BLOATED_SYNCHRONIZED_BLOCK">
		<ShortDescription>method overly synchronizes a block of code</ShortDescription>
		<LongDescription>method {1} overly synchronizes a block of code</LongDescription>
		<Details>
			<![CDATA[
			<p>This methods implements a synchronized block, but the code found at the beginning
			of this block only accesses local variables, and not member variables, or this.
			To be better performance move the code that access local variables only, above the
			synchronized block, and leave the synchronized block only for field accesses, or access
			to this object.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CLI_CONSTANT_LIST_INDEX">
		<ShortDescription>method accesses list or array with constant index</ShortDescription>
		<LongDescription>method {1} accesses list or array with constant index</LongDescription>
		<Details>
			<![CDATA[
			<p>This method accesses an array or list using a constant integer index. Often,
			this is a typo where a loop variable is intended to be used. If however, specific
			list indices mean different specific things, then perhaps replacing the list with
			a first-class object with meaningful accessors would make the code less brittle.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCR_SLOPPY_CLASS_REFLECTION">
		<ShortDescription>method accesses statically bound class with Class.forName</ShortDescription>
		<LongDescription>method {1} accesses statically bound class with Class.forName</LongDescription>
		<Details>
			<![CDATA[
			<p>This method accesses the class object of a class that is already statically bound
			in this context, with Class.forName. Using Class.forName makes reflection more fragile
			in regards to code transformations such as obfuscation, and is unneeded here, since
			the class in question is already 'linked' to this class.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AWCBR_ARRAY_WRAPPED_CALL_BY_REFERENCE">
		<ShortDescription>method uses 1 element array to simulate call by reference</ShortDescription>
		<LongDescription>method {1} uses 1 element array to simulate call by reference</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a one element array to wrap an object that is to be past to a method as an argument
			to simulate call by pointer ala C++. It is better to define a proper return class type that holds all
			the relevant information retrieved from the called method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SG_SLUGGISH_GUI">
		<ShortDescription>method performs time consuming operation in gui thread</ShortDescription>
		<LongDescription>method {1} performs time consuming operation in gui thread</LongDescription>
		<Details>
			<![CDATA[
			<p>This method implements an awt or swing listener and performs time
			consuming operations. Doing these operations in the gui thread will cause the
			interface to appear sluggish and non-responsive to the user. Consider
			using a separate thread to do the time consuming work so that the user
			has a better experience.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NIR_NEEDLESS_INSTANCE_RETRIEVAL">
		<ShortDescription>method retrieves instance to load static member</ShortDescription>
		<LongDescription>method {1} retrieves instance to load static member</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls a method to load a reference to an object, and then only
			uses it to load a static member of that instance's class. It is simpler and
			better performant to just load the static field from the class itself.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DDC_DOUBLE_DATE_COMPARISON">
		<ShortDescription>Method uses two date comparisons when one would do</ShortDescription>
		<LongDescription>Method {1} uses two date comparisons when one would do</LongDescription>
		<Details>
			<![CDATA[
			<p>This method compares dates with two comparisons, rather than using the reverse comparison.
			So This pattern
<pre>
	if ((date1.equals( date2 )) || (date1.after( date2 )))
</pre>
			could become
<pre>
	if (!date2.before( date1 ))
</pre>
			and
<pre>
	if ((date1.equals( date2 )) || (date1.before( date2 )))
</pre>
			could become
<pre>
	if (!date2.after( date1 ))
</pre>
			and
<pre>
	if ((date1.before( date2 )) || (date1.after( date2 )))
</pre>
			could become
<pre>
	if (!date1.equals( date2 ))
</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SWCO_SUSPICIOUS_WAIT_ON_CONCURRENT_OBJECT">
		<ShortDescription>method calls wait when await was probably intended</ShortDescription>
		<LongDescription>method {1} calls wait when await was probably intended</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls wait() on a on mutex defined in the java.util.concurrent package.
			These classes, define await, instead of wait, and it is most likely that await
			was intended.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JVR_JDBC_VENDOR_RELIANCE">
		<ShortDescription>method uses jdbc vendor specific classes and methods</ShortDescription>
		<LongDescription>method {1} uses jdbc vendor specific classes and methods</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses jdbc vendor specific classes and method to perform database work.
			This makes the code specific to this vendor, and unable to run on other databases.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PMB_POSSIBLE_MEMORY_BLOAT">
		<ShortDescription>class defines static field that appears to allow memory bloat</ShortDescription>
		<LongDescription>class {0} defines static field that appears to allow memory bloat</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines static fields that are collections or StringBuffers that do not
			appear to have any way to clear or reduce their size. This is a potential cause of
			memory bloat.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LSYC_LOCAL_SYNCHRONIZED_COLLECTION">
		<ShortDescription>method creates local variable-based synchronized collection</ShortDescription>
		<LongDescription>method {1} creates local variable-based synchronized collection</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a synchronized collection and store the reference to it
			in a local variable. As local variables are by definition threadsafe, it seems
			questionable that this collection needs to be synchronized.</p>
			<p>
			<table>
				<tr><th>If you are using</th><th>consider using</th></tr>
				<tr><td>java.util.Vector</td><td>java.util.ArrayList</td></tr>
				<tr><td>java.util.Hashtable</td><td>java.util.HashMap</td></tr>
				<tr><td>java.lang.StringBuffer</td><td>java.lang.StringBuilder</td></tr>
			</table>
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FCBL_FIELD_COULD_BE_LOCAL">
		<ShortDescription>class defines fields that are used only as locals</ShortDescription>
		<LongDescription>class {0} defines fields that are used only as locals</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines fields that are used in a locals only fashion,
			specifically private fields or protected fields in final classes that are accessed
			first in each method with a store vs. a load. This field could be replaced by one
			or more local variables.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NOS_NON_OWNED_SYNCHRONIZATION">
		<ShortDescription>class uses non owned variables to synchronize on</ShortDescription>
		<LongDescription>class {0} uses non owned variables to synchronize on</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a synchronize block where the object that is being synchronized on,
			is not owned by this current instance. This means that other instances may use this same
			object for synchronization for its own purposes causing synchronization confusion. It is
			always cleaner and safer to only synchronize on private fields of this class. Note that 'this'
			is not owned by the current instance, but is owned by whomever assigns it to a field of its
			class. Synchronizing on 'this' is also not a good idea.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NRTL_NON_RECYCLEABLE_TAG_LIB">
		<ShortDescription>Tag library is not recycleable</ShortDescription>
		<LongDescription>Tag library {0} is not recycleable</LongDescription>
		<Details>
			<![CDATA[
				<p>This Tag library class implements an attribute who's associated backing store field
				is modified at another point in the tag library. In order for a taglibrary to be
				recycleable, only the container is allowed to change this attribute, through the use
				of the setXXX method of the taglib. By modifying the value programmatically, the
				container will not initialize the attribute correctly on reuse.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NULL_LAYOUT">
		<ShortDescription>Gui uses absolute layout</ShortDescription>
		<LongDescription>Gui {0} uses absolute layout</LongDescription>
		<Details>
			<![CDATA[
				<p>This class passes null to setLayout, which specifies that components are
				to be laid out using absolute coordinates. This makes making changes for
				font sizes, etc, difficult as items will not reposition
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NO_SETLABELFOR">
		<ShortDescription>JLabel doesn't specify what it's labeling</ShortDescription>
		<LongDescription>JLabel in method {1} doesn't specify what it's labeling</LongDescription>
		<Details>
			<![CDATA[
				<p>This class uses JLabels that do not specify what fields are being labeled.
				This hampers screen readers from given appropriate feed back to users. Use
				the JLabel.setLabelFor method to accomplish this.
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NO_SETSIZE">
		<ShortDescription>Window sets size manually, and doesn't use pack</ShortDescription>
		<LongDescription>Window {0} sets size manually, and doesn't use pack</LongDescription>
		<Details>
			<![CDATA[
				<p>This class creates a window, and sizes the window using setSize. It is better
				to handle font size changes to use the pack method.
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NON_ACCESSIBLE_JCOMPONENT">
		<ShortDescription>Class extends JComponent but does not implement Accessible interface</ShortDescription>
		<LongDescription>Class {0} extends JComponent but does not implement Accessible interface</LongDescription>
		<Details>
			<![CDATA[
				<p>This class extends the JComponent gui control but does not implement the Accessibility interface.
				This makes this control unable to be processed by screen readers, etc, for people with reading/vision
				difficulties</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_SET_COMP_COLOR">
		<ShortDescription>Method explicitly sets the color of a Component</ShortDescription>
		<LongDescription>Method {1} Method explicitly sets the color of a Component</LongDescription>
		<Details>
			<![CDATA[
				<p>This method sets a Components explicitly foreground or background color which may
				cause difficulty with people with vision problems from using this application.
				Colors should be allowed to be set from the operating system.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UEC_USE_ENUM_COLLECTIONS">
		<ShortDescription>Class uses an ordinary set or map with an enum class as the key</ShortDescription>
		<LongDescription>Class {0} uses an ordinary set or map with an enum class as the key</LongDescription>
		<Details>
			<![CDATA[
				<p>This class uses an ordinary set or map collection and uses an enum class as the key type.
				It is better performant to use the jdk 1.5 EnumSet or EnumMap classes.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SIL_SQL_IN_LOOP">
		<ShortDescription>Method executes sql queries inside of loops</ShortDescription>
		<LongDescription>Method {1} executes sql queries inside of loops</LongDescription>
		<Details>
			<![CDATA[
				<p>This method executes sql queries inside of a loop. This pattern is often inefficient
				as the number of queries may mushroom in fencepost cases. It is probably more performant
				to loop over the input and collect the key data needed for the query for all items, and
				issue one query using an in clause, or similar construct, and then loop over this result
				set, and fetch all the data at once.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NMCS_NEEDLESS_MEMBER_COLLECTION_SYNCHRONIZATION">
		<ShortDescription>Class defines unneeded synchronization on member collection</ShortDescription>
		<LongDescription>Class {0} defines unneeded synchronization on member collection</LongDescription>
		<Details>
			<![CDATA[
				<p>This class defines a private collection member as synchronized. It appears however
				that this collection isn't only modified in a static initializer, or constructor. As these
				two areas are guaranteed to be thread safe, defining this collection as synchronized is
				unnecessary and a potential performance bottleneck.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ITC_INHERITANCE_TYPE_CHECKING">
		<ShortDescription>Method uses instanceof on multiple types to arbitrate logic</ShortDescription>
		<LongDescription>Method {1} uses instanceof on multiple types to arbitrate logic</LongDescription>
		<Details>
			<![CDATA[
				<p>This method uses the instanceof operator in a series of if/else statements to
				differentiate blocks of code based on type. If these types are related by inheritance,
				it is cleaner to just define a method in the base class, and use overridden methods
				in these classes.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SACM_STATIC_ARRAY_CREATED_IN_METHOD">
		<ShortDescription>Method creates array using constants</ShortDescription>
		<LongDescription>Method {1} creates array using constants</LongDescription>
		<Details>
			<![CDATA[
				<p>This method creates an array initialized by constants. Each time this method is called
				this array will be recreated. It would be more performant to define the array as a
				static field of the class instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS">
		<ShortDescription>Method appears to call the same method on the same object redundantly</ShortDescription>
		<LongDescription>Method {1} appears to call the same method on the same object redundantly</LongDescription>
		<Details>
			<![CDATA[
				<p>This method makes two consecutive calls to the same method using the same constant
				parameters, on the same instance without any intervening changes to the objects. If this
				method does not make changes to the object, which it appears it doesn't, then making
				two calls is just a waste. These method calls could be combined by assigning the
				result into a temporary, and using the temporary the second time.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UTA_USE_TO_ARRAY">
		<ShortDescription>Method manually creates array from collection</ShortDescription>
		<LongDescription>Method {1} manually creates array from collection</LongDescription>
		<Details>
			<![CDATA[
				<p>This method manually loops over a collection, pulling each element out and storing
				it in an array to build an array from the collection. It is easier, and clearer to use
				the built in collections method toArray. Given a collection 'mycollection' of type T, use
				mycollection.toArray(new T[mycollection.size()]);
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LEST_LOST_EXCEPTION_STACK_TRACE">
		<ShortDescription>Method throws alternative exception from catch block without history</ShortDescription>
		<LongDescription>Method {1} throws alternative exception from catch block without history</LongDescription>
		<Details>
			<![CDATA[
				<p>This method catches an exception, and throws a different exception, without incorporating the
				original exception. Doing so hides the original source of the exception making debugging and fixing
				these problems difficult. It is better to use the constructor of this new exception that takes an
				original exception so that this detail can be passed along to the user.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UCPM_USE_CHARACTER_PARAMETERIZED_METHOD">
		<ShortDescription>Method passes constant String of length 1 to character overridden method</ShortDescription>
		<LongDescription>Method {1} passes constant String of length 1 to character overridden method</LongDescription>
		<Details>
			<![CDATA[
				<p>This method passes a constant literal String of length 1 as a parameter to a method, that
				exposes a similar method that takes a character. It is simpler and more expedient to handle one
				character, rather than pass a string.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="TR_TAIL_RECURSION">
		<ShortDescription>Method employs tail recursion</ShortDescription>
		<LongDescription>Method {1} employs tail recursion</LongDescription>
		<Details>
			<![CDATA[
				<p>This method recursively calls itself as the last statement of the method
				(Tail Recursion). This method can be easily refactored into a simple loop, which
				will make it more performant, and reduce the stack size requirements.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_UNRELATED_RETURN_VALUES">
		<ShortDescription>Method returns different types of unrelated Objects</ShortDescription>
		<LongDescription>Method {1} returns different types of unrelated Objects</LongDescription>
		<Details>
			<![CDATA[
				<p>This method returns two or more unrelated types of objects (Related only through java.lang.Object).
				This will be very confusing to the code that must call it.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_CHANGE_RETURN_TYPE">
		<ShortDescription>Method returns more specific type of object than declared</ShortDescription>
		<LongDescription>Method {1} returns more specific type of object than declared</LongDescription>
		<Details>
			<![CDATA[
				<p>This method is defined to return a java.lang.Object. However, the return types
				returned from this method can be defined by a more specific class or interface. Since this
				method is not derived from a superclass or interface, it would be more clear to
				change the return type of this method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_INHERITED_METHOD_WITH_RELATED_TYPES">
		<ShortDescription>Inherited method returns more specific type of object than declared</ShortDescription>
		<LongDescription>Inherited method {1} returns more specific type of object than declared</LongDescription>
		<Details>
			<![CDATA[
				<p>This inherited method is defined to return a java.lang.Object. However, the return types returned
				from this method can be defined by a more specific class or interface. If possible consider changing the
				return type in the inheritance hierarchy of this method, otherwise the caller of this method will be brittle
				in handling of the return type.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PIS_POSSIBLE_INCOMPLETE_SERIALIZATION">
		<ShortDescription>Class doesn't serialize superclass fields</ShortDescription>
		<LongDescription>Class {0} doesn't serialize superclass fields</LongDescription>
		<Details>
			<![CDATA[
				<p>This method implements Serializable but is derived from a
				class that does not. The super class has fields that are not serialized
				because this class does not take the responsibility of writing these fields out
				either using Serializable's writeObject method, or Externalizable's writeExternal
				method. Therefore when this class is read from a stream, the superclass fields
				will only be initialized to the values specified in it's default constructor.
				If possible, change the superclass to implement Serializable, or implement
				Serializable or Externalizable methods in the child class.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SC_SUSPICIOUS_COMPARATOR_RETURN_VALUES">
		<ShortDescription>Comparator method doesn't seem to return all ordering values</ShortDescription>
		<LongDescription>Comparator method {1} doesn't seem to return all ordering values</LongDescription>
		<Details>
			<![CDATA[
				<p>This compareTo or compare method returns constant values for to represent less than,
				equals and greater than. However it does not return each type. Given that comparators
				are transitive, this seems incorrect.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NEGATIVE_BITSET_ITEM">
		<ShortDescription>Method passes a negative number as a bit to a BitSet which isn't supported</ShortDescription>
		<LongDescription>Method {1} passes a negative number as a bit to a BitSet which isn't supported</LongDescription>
		<Details>
			<![CDATA[
				<p>This method passes a constant negative value as a bit position to a java.util.BitSet. The BitSet class
				doesn't support negative values, and thus this method call will not work as expected.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_INTERN_ON_CONSTANT">
		<ShortDescription>Method calls intern on a string constant</ShortDescription>
		<LongDescription>Method {1} calls intern on a string constant</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls intern on a constant string. As constant strings are already interned, this call
				is superfluous</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NO_CHAR_SB_CTOR">
		<ShortDescription>Method appears to pass character to StringBuffer or StringBuilder integer constructor</ShortDescription>
		<LongDescription>Method {1} appears to pass character to StringBuffer or StringBuilder integer constructor</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a StringBuffer or a StringBuilder using the constructor that takes an integer, but
			appears to pass a character instead. It is probable that the author assumed that character would be appended to the
			StringBuffer/Builder, but instead the integer value of the character is used as an initial size for the buffer.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_MATH_CONSTANT">
		<ShortDescription>Method uses non standard math constant</ShortDescription>
		<LongDescription>Method {1} uses non standard math constant</LongDescription>
		<Details>
			<![CDATA[
			<p>This method defines its own version of <b>PI</b> or <b>e</b> and the value is not as precise as the
			one defined in the constants Math.PI or Math.E. Use these constants instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_STUTTERED_ASSIGNMENT">
		<ShortDescription>Method assigns a value to a local twice in a row</ShortDescription>
		<LongDescription>Method {1} assigns a value to a local twice in a row</LongDescription>
		<Details>
			<![CDATA[
			<p>This method assigns a value twice in a row in a stuttered way such as
			<code>a = a = 5;</code> This is most probably a cut and paste error where the duplicate
			assignment can be removed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_ISNAN">
		<ShortDescription>Method compares a double to Double.NAN</ShortDescription>
		<LongDescription>Method {1} compares a double to Double.NAN</LongDescription>
		<Details>
			<![CDATA[
			<p>This method compares a douhle or float to the constant Double.NaN or Float.NaN. You should use
			Double.isNaN(d) or Float.isNaN(f) if a primitive; or d.isNaN() or f.isNaN() if a boxed double, instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_BIGDECIMAL_STRING_CTOR">
		<ShortDescription>Method passes double value to BigDecimal Constructor</ShortDescription>
		<LongDescription>Method {1} passes double value to BigDecimal Constructor</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the BigDecimal constructor that takes a double, and passes a literal double constant value. Since
			the use of BigDecimal is to get better precision than double, by passing a double, you only get the precision of double number
			space. To take advantage of the BigDecimal space, pass the number as a string. </p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_STRINGBUFFER_WITH_EMPTY_STRING">
		<ShortDescription>Method passes empty string to StringBuffer of StringBuilder constructor</ShortDescription>
		<LongDescription>Method {1} passes empty string to StringBuffer of StringBuilder constructor</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the StringBuffer of StringBuilder constructor passing in a constant empty string ("").
				This is the same as calling the default constructor, but makes the code work harder. Consider passing in a
				default size instead.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_EQUALS_ON_ENUM">
		<ShortDescription>Method calls equals on an enum instance</ShortDescription>
		<LongDescription>Method {1} calls equals on an enum instance</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the equals(Object) method on an enum instance. Since enums values are singletons,
				you can use == to safely compare two enum values. In fact, the implementation for Enum.equals does just
				that.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_INVALID_BOOLEAN_NULL_CHECK">
		<ShortDescription>Method uses invalid C++ style null check on Boolean</ShortDescription>
		<LongDescription>Method {1} uses invalid C++ style null check on Boolean</LongDescription>
		<Details>
			<![CDATA[
				<p>This method attempts to check for null by just refering to the variable name
				as would be done in C++. This ordinarily would be considered a compile error, except the
				variable in question is a Boolean, which does an auto unbox to boolean.</p>
				<pre>
				if (b && b.booleanValue())
				should be
				if ((b != null) && b.booleanValue())
				</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_CHARAT">
		<ShortDescription>Method fetches character array just to do the equivalent of the charAt method</ShortDescription>
		<LongDescription>Method {1} fetches character array just to do the equivalent of the charAt method</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the toCharArray method on a String the fetch an array of characters, only
				to retrieve one of those characters by index. It is more performant to just use the charAt method.
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USELESS_TRINARY">
		<ShortDescription>Method uses a trinary operator to cast a boolean to true or false</ShortDescription>
		<LongDescription>Method {1} uses a trinary operator to cast a boolean to true or false</LongDescription>
		<Details>
			<![CDATA[
				<p>This method tests the value of a boolean and using a trinary operator to return either true or false.
				The trinary operator is completely unecessary, just use the original boolean value.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_SUSPECT_STRING_TEST">
		<ShortDescription>Method treats null and normal strings differently than an empty strings</ShortDescription>
		<LongDescription>Method {1} treats null and normal strings differently than an empty strings</LongDescription>
		<Details>
			<![CDATA[
				<p>This method tests a string, and groups null values with real strings, leaving empty strings as another
				case. This might be perfectly valid, but normally, null strings and empty strings are logically handled the same way,
				and so this test may be flawed.</p>
				<p>Pattern found is one of the following
				<pre>if ((s == null) || (s.length() > 0))</pre> -- did you mean ((s == null) || (s.length() == 0))?
				<pre>if ((s == null) || (s.length() != 0))</pre> -- did you mean ((s == null) || (s.length() == 0))?
				<pre>if ((s != null) && (s.length() == 0))</pre> -- did you mean ((s != null) && (s.length() > 0))?
				or perhaps ((s == null) || (s.length() == 0))?
				</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_STRINGBUILDER_LENGTH">
		<ShortDescription>Method converts StringBuffer or Builder to String just to get it's length</ShortDescription>
		<LongDescription>Method {1} converts StringBuffer or Builder to String just to get it's length</LongDescription>
		<Details>
			<![CDATA[
				<p>This method calls the toString method on a StringBuffer or StringBuilder only to call length() on the resulting
				string. It is faster, and less memory intensive to just call the length method directly on the StringBuffer or StringBuilder
				itself.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="BAS_BLOATED_ASSIGNMENT_SCOPE">
		<ShortDescription>Method assigns a variable in a larger scope then is needed</ShortDescription>
		<LongDescription>Method {1} assigns a variable in a larger scope then is needed</LongDescription>
		<Details>
			<![CDATA[
			<p><b>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</b>
			This method assigns a value to a variable in an outer scope compared to where the variable is actually used.
			Assuming this evaluation does not have side effects, the assignment can be moved into the inner scope (if block)
			so that its execution time isn't taken up if the if guard is false. Care should be
			taken however that the right hand side of the assignment does not contain side
			effects that are required to happen, or that changes are not made further down that
			will effect the execution of the assignment when done later on.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCII_SPOILED_CHILD_INTERFACE_IMPLEMENTATOR">
		<ShortDescription>Class implements interface by relying on unknowing superclass methods</ShortDescription>
		<LongDescription>Class {0} implements interface by relying on unknowing superclass methods</LongDescription>
		<Details>
			<![CDATA[
			<p>This class declares that it implements an interface, but does so by relying on methods supplied
			by superclasses, even though those superclasses know nothing about the interface in question. If you wish
			to have the child not implement all the methods of the interface, it would probably be better to declare
			the superclass as implementing the interface, and if that class does not provide all the methods, then declare
			that superclass abstract.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DWI_DELETING_WHILE_ITERATING">
		<ShortDescription>Method deletes collection element while iterating</ShortDescription>
		<LongDescription>Method {1} deletes collection element while iterating</LongDescription>
		<Details>
			<![CDATA[
			<p>This method removes items from a collection using the remove method of the collection, while
			at the same time iterating across the collection. Doing this will invalidate the iterator, and further
			use of it, will cause ConcurrentModificationExceptions to be thrown. To avoid this, the remove
			method of the iterator should be used.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DWI_MODIFYING_WHILE_ITERATING">
		<ShortDescription>Method modifies collection element while iterating</ShortDescription>
		<LongDescription>Method {1} modifies collection element while iterating</LongDescription>
		<Details>
			<![CDATA[
			<p>This method modifies the contents of a collection using the collection api methods, while
			at the same time iterating across the collection. Doing this will invalidate the iterator, and further
			use of it, will cause ConcurrentModificationExceptions to be thrown.
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="USS_USE_STRING_SPLIT">
		<ShortDescription>Method builds String array using String Tokenizing</ShortDescription>
		<LongDescription>Method {1} builds String array using String Tokenizing</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a StringTokenizer to split up a String and then walks thru the
			separated elements and builds an array from these enumerated values. It is simpler
			and easier to use the String.split method.</p>
			<p>PLEASE NOTE: String.split will return an array of 1 element when passed the
			empty string, as opposed to using StringTokenizer which returns false on the first
			hasMoreElements/hasMoreTokens call. So you may need to use</p>
			<pre>
				if (s.length() > 0)
					return s.split(";");
				return new String[0];
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SJVU_SUSPICIOUS_JDK_VERSION_USE">
		<ShortDescription>method uses rt.jar class or method that does not exist</ShortDescription>
		<LongDescription>method {1} uses rt.jar class or method that does not exist for the version the class is compiled for</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls a method that does not exist, on a class that does not exist in the jdk that
			this class has been compiled for. This can happen if you compile the class specifying the -source and
			-target options, and use a version that is before the version of the compiler's JDK.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UAA_USE_ADD_ALL">
		<ShortDescription>method uses simple loop to copy contents of one collection to another</ShortDescription>
		<LongDescription>method {1} uses simple loop to copy contents of one colleciton to another</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a simple for loop to copy the contents of a set, list, map key/value, array or other collection
			to another collection. It is simpler and more straight forward to just call the addAll method of the destination collection
			passing in the source collection. In the case that the source is an array, you can use Array.asList method to massage the array
			into a collection</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MRC_METHOD_RETURNS_CONSTANT">
		<ShortDescription>private method only returns one constant value</ShortDescription>
		<LongDescription>private method {1} only returns one constant value</LongDescription>
		<Details>
			<![CDATA[
			<p>This private method only returns one constant value. As this method is private,
			it's behavior can't be overridden, and thus the return of a constant value seems dubious.
			Either the method should be changed to return no value, or perhaps another return value
			was expected to be returned in another code path in this method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NCS_NEEDLESS_CUSTOM_SERIALIZATION">
		<ShortDescription>method needlessly implements what is default streaming behavior</ShortDescription>
		<LongDescription>method {1} needlessly implements what is default streaming behavior</LongDescription>
		<Details>
			<![CDATA[
			<p>This method implements the Serializable interface by performing the same operations that
			would be done if this method did not exist. Since this is the case, this method is not needed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MOM_MISLEADING_OVERLOAD_MODEL">
		<ShortDescription>class 'overloads' a method with both instance and static versions</ShortDescription>
		<LongDescription>class {0} 'overloads' a method with both instance and static versions</LongDescription>
		<Details>
			<![CDATA[
			<p>This class 'overloads' the same method with both an instance and static version. As the use
			of these two models is different, it will be confusing to the users of these methods.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS">
		<ShortDescription>unconstrained method converts checked exception to unchecked</ShortDescription>
		<LongDescription>unconstrained method {1} converts checked exception to unchecked</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is not constrained by an interface or superclass, but converts a caught checked exception
			to unchecked exception and thrown. It would be more appropriate just throw the checked exception, adding
			the exception to the throws clause of the method.
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_HAS_CHECKED">
		<ShortDescription>constrained method converts checked exception to unchecked instead of another allowable checked exception</ShortDescription>
		<LongDescription>constrained method {1} converts checked exception to unchecked instead of another allowable checked exception</LongDescription>
		<Details>
			<![CDATA[
			<p>This method's exception signature is constrained by an interface of super class to not throw a
			checked exception that was caught. Therefore this exception was converted to an unchecked exception and
			thrown. It would probably be better to throw the closest checked exception allowed, and to annotate
			the new exception with the original exception using the initial cause field.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CHECKED">
		<ShortDescription>constrained method converts checked exception to unchecked</ShortDescription>
		<LongDescription>constrained method {1} converts checked exception to unchecked</LongDescription>
		<Details>
			<![CDATA[
			<p>This method's exception signature is constrained by an interface or super class to not throw
			any checked exceptions. Therefore a caught checked exception was converted to an unchecked exception
			and thrown. However it appears that the class in question is owned by the same author as the constraining
			interface or superclass. Consider changes the signature of this method to include the checked exception.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CFS_CONFUSING_FUNCTION_SEMANTICS">
		<ShortDescription>method returns modified parameter</ShortDescription>
		<LongDescription>method {1} returns modified parameter</LongDescription>
		<Details>
			<![CDATA[
			<p>This method appears to modify a parameter, and then return this parameter as the
			methods return value. This will be confusing to callers of this method, as it won't be
			apparent that the 'original' passed in parameter will be changed as well. If the purpose
			of this method is to change the parameter, it would be more clear to change the method to
			a have a void return value. If a return type is required due to interface or superclass contract,
			perhaps a clone of the parameter should be made.</p>
			]]>
		</Details>
	</BugPattern>

	<!-- BugCode -->

	<BugCode abbrev="ISB">Inefficient String Buffering</BugCode>
	<BugCode abbrev="SCI">Synchronized Collection Iterators</BugCode>
	<BugCode abbrev="CC">Cyclomatic Complexity</BugCode>
	<BugCode abbrev="OCP">Overly Concrete Parameters</BugCode>
	<BugCode abbrev="LII">List Indexed Iterating</BugCode>
	<BugCode abbrev="UCC">Unrelated Collection Contents</BugCode>
	<BugCode abbrev="DRE">Declared Runtime Exception</BugCode>
	<BugCode abbrev="CE">Class Envy</BugCode>
	<BugCode abbrev="LSC">Literal String Comparison</BugCode>
	<BugCode abbrev="PCOA">Partially Constructed Object Access</BugCode>
	<BugCode abbrev="DLC">Dubious List Collection</BugCode>
	<BugCode abbrev="PL">Parallel Lists</BugCode>
	<BugCode abbrev="FP">Final Parameters</BugCode>
	<BugCode abbrev="ACEM">Abstract Class Empty Methods</BugCode>
	<BugCode abbrev="MAC">Manual Array Copy</BugCode>
	<BugCode abbrev="FPL">Floating Point Loops</BugCode>
	<BugCode abbrev="NCMU">Non Collection Method Use</BugCode>
	<BugCode abbrev="CAO">Confusing Autoboxed Overloading</BugCode>
	<BugCode abbrev="AFBR">Abnormal Finally Block Return</BugCode>
	<BugCode abbrev="SMII">Static Method Instance Invocation</BugCode>
	<BugCode abbrev="STS">Spurious Thread States</BugCode>
	<BugCode abbrev="NAB">Needless Autoboxing</BugCode>
	<BugCode abbrev="USBR">Unnecessary Store Before Return</BugCode>
	<BugCode abbrev="COM">Copied Overridden Method</BugCode>
	<BugCode abbrev="ABC">Array Based Collection</BugCode>
	<BugCode abbrev="ODN">Orphaned DOM Node</BugCode>
	<BugCode abbrev="AOM">Abstract Overridden Method</BugCode>
	<BugCode abbrev="CBX">Custom Built XML</BugCode>
	<BugCode abbrev="BSB">Bloated Synchronized Block</BugCode>
	<BugCode abbrev="CLI">Constant List Index</BugCode>
	<BugCode abbrev="SCR">Sloppy Class Reflection</BugCode>
	<BugCode abbrev="AWCBR">Array Wrapped Call By Reference</BugCode>
	<BugCode abbrev="SG">Sluggish Gui</BugCode>
	<BugCode abbrev="NIR">Needless Instance Retrieval</BugCode>
	<BugCode abbrev="DDC">Double Date comparison</BugCode>
	<BugCode abbrev="SWCO">Suspicious Wait on Concurrent Object</BugCode>
	<BugCode abbrev="JVR">JDBC Vendor Reliance</BugCode>
	<BugCode abbrev="PMB">Possible Memory Bloat</BugCode>
	<BugCode abbrev="LSYC">Local Synchronized Collection</BugCode>
	<BugCode abbrev="FCBL">Field Could Be Local</BugCode>
	<BugCode abbrev="NOS">Non Owned Synchronization</BugCode>
	<BugCode abbrev="NRTL">Non Recycleable Taglib</BugCode>
	<BugCode abbrev="S508C">Section 508 Compliance Violations</BugCode>
	<BugCode abbrev="UEC">Use Enum Collections</BugCode>
	<BugCode abbrev="SIL">SQL In Loop</BugCode>
	<BugCode abbrev="NMCS">Needless Member Collection Synchronization</BugCode>
	<BugCode abbrev="ITC">Inheritance Type Checking</BugCode>
	<BugCode abbrev="SACM">Static Array Created in Method</BugCode>
	<BugCode abbrev="PRMC">Possibly Redundant Method Calls</BugCode>
	<BugCode abbrev="UTA">Use toArray</BugCode>
	<BugCode abbrev="LEST">Lost Exception Stack Trace</BugCode>
	<BugCode abbrev="UCPM">Use Character Parameterized Method</BugCode>
	<BugCode abbrev="TR">Tail Recursion</BugCode>
	<BugCode abbrev="URV">Unrelated Return Values</BugCode>
	<BugCode abbrev="PIS">Possible Incomplete Serialization</BugCode>
	<BugCode abbrev="SCRV">Suspicious Comparator Return Values</BugCode>
	<BugCode abbrev="SPP">Sillyness Pot Pourri</BugCode>
	<BugCode abbrev="BAS">Bloated Assignment Scope</BugCode>
	<BugCode abbrev="SCII">Spoiled Child Interface Implementor</BugCode>
	<BugCode abbrev="DWI">Deleting While Iterating</BugCode>
	<BugCode abbrev="USS">Use String Split</BugCode>
	<BugCode abbrev="SJVU">Suspicious JDK Version Use</BugCode>
	<BugCode abbrev="UAA">Use Add All</BugCode>
	<BugCode abbrev="MRC">Method Returns Constant</BugCode>
	<BugCode abbrev="NCS">Needless Custom Serialization</BugCode>
	<BugCode abbrev="MOM">Misleading Overload Model</BugCode>
	<BugCode abbrev="EXS">Exception Softening</BugCode>
	<BugCode abbrev="CFS">Confusing Function Semantics</BugCode>
</MessageCollection>